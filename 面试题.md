# a. 第一阶段

## 1. url 到浏览器发生了什么

### 1、输入网址

当你开始输入网址比如www.cnblogs.com时游览器就可以在书签或者历史记录里面去搜索相关的网址推荐给你。

### 2、游览器查找域名的IP地址

① 请求发起后，游览器首先会解析这个域名，首先它会查看本地硬盘的 hosts 文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用 hosts 文件里面的 ip 地址。

② 如果在本地的 hosts 文件没有能够找到对应的 ip 地址，浏览器会发出一个 DNS请求到本地DNS(域名分布系统)服务器 。本地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动。

③查询你输入的网址的DNS请求到达本地DNS服务器之后，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果，此过程是递归的方式进行查询。如果没有，本地DNS服务器还要向DNS根服务器进行查询

④根DNS服务器没有记录具体的域名和IP地址的对应关系，而是告诉本地DNS服务器，你可以到域服务器上去继续查询，并给出域服务器的地址。这种过程是迭代的过程

⑤本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址

⑥最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。

![img](https://images2017.cnblogs.com/blog/1171046/201712/1171046-20171226173034151-855747573.jpg)

### 3、建立TCP链接

在拿到域名对应的IP地址后，会以随机端口（1024~~65535）向WEB服务器程序80端口发起TCP的连接请求，这个连接请求进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序，最终建立了TCP/IP的连接，对于客户端与服务器的TCP链接，必然要说的就是『三次握手』。

![img](https://img2018.cnblogs.com/blog/1171046/201904/1171046-20190409190539159-883745097.png)

　　　　　　　　　　三次握手

客户端发送一个带有SYN标志的数据包给服务端，服务端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息，最后客户端再回传一个带ACK标志的数据包，代表握手结束，连接成功。

通俗化之后就是：

客户端：老弟我要跟你链接

服务端：好的，同意了

客户端：好嘞

### 4、游览器向WEB服务器发起Http请求

建立TCP连接之后，发起HTTP请求，请求一般分为三部分

请求方法URI协议/版本

请求头(Request Header)

请求正文

下面是一个完整的请求

![img](https://img-blog.csdn.net/20180519235118178?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FsZXhzaGk1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

详细的就不描述了，网上很多说明的。

###  5、服务器端处理

服务器端收到请求后的由web服务器（准确说应该是http服务器）处理请求，诸如Apache、Ngnix、IIS等。web服务器解析用户请求，知道了需要调度哪些资源文件，再通过相应的这些资源文件处理用户请求和参数，并调用数据库信息，最后将结果通过web服务器返回给浏览器客户端。

![img](https://img2018.cnblogs.com/blog/1171046/201904/1171046-20190409191054591-1163748805.png)

### 6、关闭TCP链接

为了避免服务器与客户端双方的资源占用和损耗，当双方没有请求或响应传递时，任意一方都可以发起关闭请求。与创建TCP连接的3次握手类似，关闭TCP连接，需要4次握手。

![img](https://img2018.cnblogs.com/blog/1171046/201904/1171046-20190409191208891-688664454.png)

上图可以通俗化：

客户端：老弟，我这边没数据要传了，咱们关闭链接吧

服务端：好的，接收到了，我看看我这边还有没有要传的

服务端：我这边也没有了，关闭吧

客户端：好嘞

### 7、游览器解析资源

对于获取到的HTML、CSS、JS、图片等等资源。

浏览器通过解析HTML，生成DOM树，解析CSS，生成CSS规则树，然后通过DOM树和CSS规则树生成渲染树。渲染树与DOM树不同，渲染树中并没有head、display为none等不必显示的节点。

在解析CSS的同时，可以继续加载解析HTML，但在解析执行JS脚本时，会停止解析后续HTML，这就会出现阻塞问题，关于JS阻塞相关问题，这里不过多阐述,后面会单独开篇讲解。

![img](https://user-gold-cdn.xitu.io/2018/2/22/161bb3c9b220f8cb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

　　　　　　　　　　webkit渲染流程

### 8、游览器布局渲染

根据渲染树布局，计算CSS样式，即每个节点在页面中的大小和位置等几何信息。HTML默认是流式布局的，CSS和js会打破这种布局，改变DOM的外观样式以及大小和位置。这时就要提到两个重要概念：repaint和reflow。

repaint：屏幕的一部分重画，不影响整体布局，比如某个CSS的背景色变了，但元素的几何尺寸和位置不变。

reflow： 意味着元件的几何尺寸变了，我们需要重新验证并计算渲染树。是渲染树的一部分或全部发生了变化。这就是Reflow，或是Layout。

有些情况下，比如修改了元素的样式，浏览器并不会立刻 reflow 或 repaint 一次，而是会把这样的操作积攒一批，然后做一次 reflow，这又叫异步 reflow 或增量异步 reflow。
有些情况下，比如 resize 窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行 reflow。







## 2. setState之后 发生了什么

setState 作为react中使用最高的api,今天我们就来看一下setState之后,发生了什么？

首先我们先来看setState两个基本特性:

1 setState是异步的,react通常会集齐一些组件后一起更新组件，以保证性能。所以当我们在设置setState后，立即通过this.state是获取最新状态是获取不到的。如果要获取最新的状态可以在setState回调中获取。

```text
this.setState({name: 'laodao'},()=>{})
```

2 setState进行多次执行，在react执行合并多次为一次情况下，相当于后面覆盖前面，相当于加一次。

```js
Object.assign(
  previousState,
  {quantity: this.state.quantity + 1},
  {quantity: this.state.quantity + 1}
)
```

## 3. setState()更新状态是异步/同步?

​    a. 执行setState()的位置?

​      在react控制的回调函数中: 生命周期勾子 / react事件监听回调

​      非react控制的异步回调函数中: 定时器回调 / 原生DOM事件监听回调 / promise回调 /...

​    b. 异步 OR 同步?

​      react相关回调中（生命周期回调、事件监听回调）: 异步

​      其它异步回调中（定时器、原生DOM事件监听回调、Promsie回调）: 同步



## 4. 垃圾回收

**1）问什么是垃圾**

一般来说没有被引用的对象就是垃圾，就是要被清除， 有个例外如果几个对象引用形成一个环，互相引用，但根访问不到它们，这几个对象也是垃圾，也要被清除。

## 5. 事件轮询

**事件轮询 (eventloop) 是"一个解决和处理外部事件时将它们转换为回调函数的调用的实体(entity)**


异步执行机制
所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。
主线程之外，还存在一个 " 任务队列 "（task queue）。只要异步任务有了运行结果，就在 " 任务队列 " 之中放置一个事件。
一旦 " 执行栈 " 中的所有同步任务执行完毕，系统就会读取 " 任务队列 "，看看里面有哪些事件。于是那些对应的异步任务结束等待状态，进入执行栈，开始执行。
主线程不断重复上面的第三步（事件轮询）
JS中事件队列的优先级
在 JS 的ES6 中新增的任务队列（promise）优先级是在事件循环之上的，事件循环每次 tick 后会查看 ES6 的任务队列中是否有任务要执行，也就是 ES6 的任务队列比事件循环中的任务（事件）队列优先级更高。

先执行同步代码再执行异步代码，先执行微任务再执行宏任务

setTimeout( fn, 0 )，它在 " 任务队列 " 的尾部添加一个事件，因此要等到同步任务和 " 任务队列 " 现有的事件都处理完，才会得到执行。

```js
console.log(1)
setTimeout(function () {
	console.log(6)
}, 1000)
new Promise(function (resolve, reject) {
    console.log(2)
    setTimeout(function () {
        console.log(3)
    }, 500)
    resolve()
}).then(function (res) {
    console.log(4)
})
console.log(5)

// 1 2 5 4 3 6

```

微观任务队列
    微任务：语言标准（ECMAScript）提供，如process.nextTick(node)、Promise、Object.observe、MutationObserver

宏观任务队列
    宏任务：由宿主环境提供，比如setTimeout、setInterval、网络请求Ajax、用户I/O、script（整体代码）、UI rendering、setImmediate（node）









## 6. useState 为什么不能写在 if else 中

这是因为React通过单链表来管理Hooks 。

update 阶段，每次调用 useState，链表就会执行 next 向后移动一步。如果将 useState 写在条件判断中，
假设条件判断不成立，没有执行里面的 useState 方法，
会导致接下来所有的 useState 的取值出现偏移，从而导致异常发生。



## 7. 强缓存 弱缓存

在浏览器众多缓存中的HTTP缓存可能很多人对这个的概念并没有很清晰，每个人都知道进入一次网页之后再刷新一次页面，加载速度会比首次加载快非常多，每个人都知道这是浏览器缓存的magic，但是对此背后的原因可能不甚了解...

### 当我们在谈论HTTP缓存时我们在谈论什么:

我们实际上是在谈论下面这两种情况:

![img](https://segmentfault.com/img/remote/1460000017457443?w=1849&h=301)

如上图，浏览器对静态资源的HTTP缓存有两种情况，一种是强缓存(本地缓存)，另一种是弱缓存(协商缓存)。

------

### 缓存流程：

#### 浏览器第一次请求资源时：

![图片出自网络](https://segmentfault.com/img/remote/1460000017457444?w=686&h=382)

浏览器**第一次请求资源时，必须下载所有的资源，然后根据响应的header内容来决定，如何缓存资源**。可能采用的是强缓存，也可能是弱缓存

#### 浏览器后续请求资源时的匹配流程：

![img](https://segmentfault.com/img/remote/1460000017457445?w=401&h=861)

由上图可以知道当浏览器请求一个静态资源时的HTTP流程：

1. 强缓存阶段：先在本地查找该资源，如果发现该资源，并且其他限制也没有问题(比如:缓存有效时间)，就命中强缓存，返回200，直接使用强缓存，并且不会发送请求到服务器
2. 弱缓存阶段：在本地缓存中找到该资源，发送一个http请求到服务器，服务器判断这个资源没有被改动过，则返回304，让浏览器使用该资源。
3. 缓存失败阶段(重新请求)：当服务器发现该资源被修改过，或者在本地没有找到该缓存资源，服务器则返回该资源的数据。

### 强缓存与弱缓存的区别：

**获取资源形式**： 都是从缓存中获取资源的。

**状态码**： 强缓存返回200(from cache),弱缓存返回304状态码

**请求(最大区别)**：

强缓存不发送请求，直接从缓存中取。

弱缓存需要发送一个请求，验证这个文件是否可以使用（有没有被改动过）。

------

### 强缓存：

强缓存是利用Expires或者Cache-Control，让原始服务器为文件设置一个过期时间，在多长时间内可以将这些内容视为最新的。

若时间未过期，则命中强缓存，使用缓存文件不发送请求。

### Cache-Control

Cache-Control 是http1.1中为了弥补`Expires`的缺陷而加入的，当Expires和Cache-Control同时存在时，Cache-Control优先级高于Expires。

**选项**：

可缓存性:

`public`： 服务器端和浏览器端都能缓存

`private`: 只能浏览器端缓存

`no-cache`: 强制浏览器在使用cache拷贝之前先**提交一个http请求到源服务器进行确认**。http请求没有减少，会减少一个响应体(文件内容),这种个选项类似弱缓存。

`only-if-cached`: 表明客户端只接受已缓存的响应，并且不要向原始服务器检查是否有更新的拷贝。

到期设置：

`max-age=60`：设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)。 这里是60秒

其他设置：

`no-store`: 不缓存，使用协商缓存

`must-revalidate`: 缓存必须在使用之前验证旧资源的状态，并且不可使用过期资源。

更多设置，移动[MDN](https://link.segmentfault.com/?enc=SvYVsjkdJayuZjBJOvSBDQ%3D%3D.wWuc9Img9%2FSiDl8rdu2U9SjZJHXJ1Et%2BQAY5R96PhCWqbou%2BVeqLTwHYrQI7Q7yjLmsEYnKpaLeJ4m2iXElDBE4bA4mGbbkNXe%2FtuOKE2GE%3D)

```javascript
// 示例
Cache-Control: no-cache, no-store, must-revalidate
Cache-Control:public, max-age=31536000
Cache-Control: max-age=3600, must-revalidate
```

### http1.0时代的缓存 Expires+Pragma

**Expires用于设置缓存到期时间**：

指定缓存到期GMT的绝对时间，如果设了max-age，max-age就会覆盖expires，如果expires到期需要重新请求。

```javascript
Expires:Sat, 09 Jun 2018 08:13:56 GMT
```

有一个问题是由于使用具体时间，如果时间表示出错或者没有转换到正确的时区都可能造成缓存生命周期出错。

**Pragma禁用缓存：**

`Pragma : no-cache` 表示防止客户端缓存，需要强制从服务器获取最新的数据；

```javascript
Pragma : no-cache  //只有这一个用法 禁用缓存，强制从服务器获取最新的数据； 
```

### 强缓存命中 from memory cache & from disk cache

在测试的时候，看到命中强缓存时，有两种状态，200 (from memory cache) cache & 200 (from disk cache)，于是去找了一下这两者的区别：

memory cache: 将资源存到**内存**中，从内存中获取。

disk cache：将资源缓存到**磁盘**中，从磁盘中获取。

二者最大的区别在于：**当退出进程时，内存中的数据会被清空，而磁盘的数据不会**。

更详细的介绍推荐这篇[文章](https://link.segmentfault.com/?enc=pwzeFy4N5ouxd9n6uUPeAQ%3D%3D.96mETHLjd446Q52uhd7vNLC%2B38OMhLUaLfMwOFzfxRHaWQ7KrSc3Tn6RV1Hvmu0M0g4c%2F3Kq2P3rmR%2BPda2YQA%3D%3D)

------

### 弱缓存：

如果强缓存时间过期，或者没有设置，导致未命中的话。就进入到了弱缓存的阶段了，

**Last-Modified & if-modified-since:**

Last-Modified与If-Modified-Since是一对报文头，属于http 1.0。

last-modified是web服务器认为文件的最后修改时间，`last-modified`是第一次请求文件的时候，**服务器返回**的一个属性。

```javascript
Last-Modified: Sat, 09 Jun 2018 08:13:56 GMT 
```

第二次请求这个文件时，浏览器把`If-Modified-Since`**发送给服务器**，询问该时间之后文件是否被修改过。

```javascript
If-Modified-Since: Sat, 09 Jun 2018 08:13:56 GMT // 跟Last-Modified的值一样
```

**ETag & If-None-Match**

ETag与If-None-Match是一对报文，属于http 1.1。

**ETag是一个文件的唯一标志符**。就像一个哈希或者指纹，每个文件都有一个单独的标志，只要这个文件发生了改变，这个标志就会发生变化。

ETag机制类似于乐观锁机制，如果请求报文的ETag与服务器的不一致，则表示该资源已经被修改过来，需要发最新的内容给浏览器。

`ETag`也是首次请求的时候，服务器返回的:

```javascript
ETag: "8F759D4F67D66A7244638AD249675BE2" // 长这样
```

`If-None-Match`也是浏览器发送到服务器验证，文件是否改变的:

```javascript
If-None-Match: "8F759D4F67D66A7244638AD249675BE2" // 跟ETag的值一样
```

### **Etag/lastModified过程如下:**

1. 客户端第一次向服务器发起请求,服务器将附加`Last-Modified/ETag`到所提供的资源上去
2. 当再一次请求资源,**如果没有命中强缓存**,在执行在验证时,**将上次请求时服务器返回的Last-Modified/ETag一起传递给服务器**。
3. 服务器检查该Last-Modified或ETag，并判断出该资源**页面自上次客户端请求之后还未被修改，返回响应304和一个空的响应体**。

### 同时使用两个报文头:

同时使用这两个报文头，**两个都匹配才会命中弱缓存**，否则将重新请求资源。

![img](https://segmentfault.com/img/remote/1460000017457446?w=975&h=583)

### Etag 主要为了解决 Last-Modified 无法解决的一些问题：

1. 一些文件也许内容并不改变(仅仅改变的修改时间)，这个时候我们不希望文件重新加载。（Etag值会触发缓存，Last-Modified不会触发）
2. If-Modified-Since能检查到的粒度是秒级的，当修改非常频繁时，Last-Modified会触发缓存，而Etag的值不会触发，重新加载。
3. 某些服务器不能精确的得到文件的最后修改时间。

------

### 用户操作行为与缓存

F5刷新导致强缓存失效。

ctrl+F5强制刷新页面强缓存，弱缓存都会失效。

![图片出自网络](https://segmentfault.com/img/remote/1460000017457447?w=495&h=175)

### 如何设置？

一般是服务器端设置这些请求头的，我自己试了用阿里云服务器设置`Cache-Control`，设置一下很方便的。

------





## 8. forEach、for in 、 for of三者的区别

### 1. for循环

其实除了这三种方法以外还有一种最原始的遍历，自Javascript诞生起就一直用的 就是for循环，它用来遍历数组

for循环中可以使用return、break等来中断循环

```js
var arr = [1,2,3,4]
for(var i = 0 ; i< arr.length ; i++){
	console.log(arr[i])
}

// 1 2 3 4

```



### 2. forEach

对数组的每一个元素执行一次提供的函数（不能使用return、break等中断循环），不改变原数组，无返回值undefined。

```js
let arr = ['a', 'b', 'c', 'd']
arr.forEach(function (val, idx, arr) {
    console.log(val + ', index = ' + idx) // val是当前元素，index当前元素索引，arr数组
    console.log(arr)
})

输出结果：

a, index = 0
(4) ["a", "b", "c", "d"]
b, index = 1
(4) ["a", "b", "c", "d"]
c, index = 2
(4) ["a", "b", "c", "d"]
d, index = 3
(4) ["a", "b", "c", "d"]

```

### 3. for…in

循环遍历的值都是数据结构的键值

总结一句: for in也可以循环数组但是特别适合遍历对象

```js
let obj = {a: '1', b: '2', c: '3', d: '4'}
for (let o in obj) {
    console.log(o)    //遍历的实际上是对象的属性名称 a,b,c,d
    console.log(obj[o])  //这个才是属性对应的值1，2，3，4
}

```



### 4. for…of

它是ES6中新增加的语法，用来循环获取一对键值对中的值

1. 循环一个数组

```js
let arr = ['China', 'America', 'Korea']
for (let o of arr) {
    console.log(o) //China, America, Korea
}

```

2. 循环一个普通对象（报错）

```js
let obj = {a: '1', b: '2', c: '3', d: '4'}
for (let o of obj) {
    console.log(o)   //Uncaught TypeError: obj[Symbol.iterator] is not a function
}

```

**一个数据结构只有部署了 Symbol.iterator 属性, 才具有 iterator接口可以使用 for of循环。例子中的obj对象没有Symbol.iterator属性 所以会报错。**

<span style="background:yellow">哪些数据结构部署了 Symbol.iteratoer属性了呢?</span>

**数组 Array**
**Map**
**Set**
**String**
**arguments对象**
**Nodelist对象, 就是获取的dom列表集合**

```js
如果想让对象可以使用 for of循环怎么办?使用 Object.keys() 获取对象的 key值集合后,再使用 for of

let obj = {a: '1', b: '2', c: '3', d: '4'}
for (let o of Object.keys(obj)) {
    console.log(o) // a,b,c,d
}

或者使用内置的Object.values()方法获取对象的value值集合再使用for of

let obj = {a: '1', b: '2', c: '3', d: '4'}
for (let o of Object.values(obj)) {
    console.log(o) // 1,2,3,4
}
```

3. 循环一个字符串

```js
let str = 'love'
for (let o of str) {
    console.log(o) // l,o,v,e
}

```

4. 循环一个Map

```js
let iterable = new Map([["a", 1], ["b", 2], ["c", 3]]);

for (let [key, value] of iterable) {
  console.log(value);
}
// 1
// 2
// 3

for (let entry of iterable) {
  console.log(entry);
}
// [a, 1]
// [b, 2]
// [c, 3]
```

5. 循环一个Set

```js
let iterable = new Set([1, 1, 2, 2, 3, 3]);

for (let value of iterable) {
  console.log(value);
}
// 1
// 2
// 3


```

数组去重，一般都是在面试的时候才会碰到，一般是要求手写数组去重方法的代码。如果是被提问到，数组去重的方法有哪些？你能答出其中的10种，面试官很有可能对你刮目相看。
在真实的项目中碰到的数组去重，一般都是后台去处理，很少让前端处理数组去重。虽然日常项目用到的概率比较低，但还是需要了解一下，以防面试的时候可能回被问到。

注：写的匆忙，加上这几天有点忙，还没有非常认真核对过，不过思路是没有问题，可能一些小细节出错而已。

## 9. 数组去重的方法

### 1. 利用ES6 Set去重（ES6中最常用）

```js
function unique (arr) {
  return Array.from(new Set(arr))
}
var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
console.log(unique(arr))
 //[1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", {}, {}]
```

不考虑兼容性，这种去重的方法代码最少。这种方法还无法去掉“{}”空对象，后面的高阶方法会添加去掉重复“{}”的方法。

### 2. 利用for嵌套for，然后splice去重（ES5中最常用）

```js
function unique(arr){            
        for(var i=0; i<arr.length; i++){
            for(var j=i+1; j<arr.length; j++){
                if(arr[i]==arr[j]){         //第一个等同于第二个，splice方法删除第二个
                    arr.splice(j,1);
                    j--;
                }
            }
        }
return arr;
}
var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
    console.log(unique(arr))
    //[1, "true", 15, false, undefined, NaN, NaN, "NaN", "a", {…}, {…}]     //NaN和{}没有去重，两个null直接消失了
```

双层循环，外层循环元素，内层循环时比较值。值相同时，则删去这个值。
想快速学习更多常用的ES6语法，可以看我之前的文章[《学习ES6笔记──工作中常用到的ES6语法》](https://segmentfault.com/a/1190000016068235)。

### 3. 利用indexOf去重

```js
function unique(arr) {
    if (!Array.isArray(arr)) {
        console.log('type error!')
        return
    }
    var array = [];
    for (var i = 0; i < arr.length; i++) {
        if (array .indexOf(arr[i]) === -1) {
            array .push(arr[i])
        }
    }
    return array;
}
var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
console.log(unique(arr))
   // [1, "true", true, 15, false, undefined, null, NaN, NaN, "NaN", 0, "a", {…}, {…}]  //NaN、{}没有去重
```

新建一个空的结果数组，for 循环原数组，判断结果数组是否存在当前元素，如果有相同的值则跳过，不相同则push进数组。

### 4. 利用sort()

```js
function unique(arr) {
    if (!Array.isArray(arr)) {
        console.log('type error!')
        return;
    }
    arr = arr.sort()
    var arrry= [arr[0]];
    for (var i = 1; i < arr.length; i++) {
        if (arr[i] !== arr[i-1]) {
            arrry.push(arr[i]);
        }
    }
    return arrry;
}
     var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
        console.log(unique(arr))
// [0, 1, 15, "NaN", NaN, NaN, {…}, {…}, "a", false, null, true, "true", undefined]      //NaN、{}没有去重
```

利用sort()排序方法，然后根据排序后的结果进行遍历及相邻元素比对。

### 5. 利用对象的属性不能相同的特点进行去重（这种数组去重的方法有问题，不建议用，有待改进）

```js
function unique(arr) {
    if (!Array.isArray(arr)) {
        console.log('type error!')
        return
    }
    var arrry= [];
     var  obj = {};
    for (var i = 0; i < arr.length; i++) {
        if (!obj[arr[i]]) {
            arrry.push(arr[i])
            obj[arr[i]] = 1
        } else {
            obj[arr[i]]++
        }
    }
    return arrry;
}
    var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
        console.log(unique(arr))
//[1, "true", 15, false, undefined, null, NaN, 0, "a", {…}]    //两个true直接去掉了，NaN和{}去重
```

### 6. 利用includes

```js
function unique(arr) {
    if (!Array.isArray(arr)) {
        console.log('type error!')
        return
    }
    var array =[];
    for(var i = 0; i < arr.length; i++) {
            if( !array.includes( arr[i]) ) {//includes 检测数组是否有某个值
                    array.push(arr[i]);
              }
    }
    return array
}
var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
    console.log(unique(arr))
    //[1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", {…}, {…}]     //{}没有去重
```

### 7. 利用hasOwnProperty

```js
function unique(arr) {
    var obj = {};
    return arr.filter(function(item, index, arr){
        return obj.hasOwnProperty(typeof item + item) ? false : (obj[typeof item + item] = true)
    })
}
    var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
        console.log(unique(arr))
//[1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", {…}]   //所有的都去重了
```

利用hasOwnProperty 判断是否存在对象属性

### 8. 利用filter

```js
function unique(arr) {
  return arr.filter(function(item, index, arr) {
    //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素
    return arr.indexOf(item, 0) === index;
  });
}
    var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
        console.log(unique(arr))
//[1, "true", true, 15, false, undefined, null, "NaN", 0, "a", {…}, {…}]
```

### 9. 利用递归去重

```js
function unique(arr) {
        var array= arr;
        var len = array.length;

    array.sort(function(a,b){   //排序后更加方便去重
        return a - b;
    })

    function loop(index){
        if(index >= 1){
            if(array[index] === array[index-1]){
                array.splice(index,1);
            }
            loop(index - 1);    //递归loop，然后数组去重
        }
    }
    loop(len-1);
    return array;
}
 var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
console.log(unique(arr))
//[1, "a", "true", true, 15, false, 1, {…}, null, NaN, NaN, "NaN", 0, "a", {…}, undefined]
```

### 10. 利用Map数据结构去重

```js
function arrayNonRepeatfy(arr) {
  let map = new Map();
  let array = new Array();  // 数组用于返回结果
  for (let i = 0; i < arr.length; i++) {
    if(map .has(arr[i])) {  // 如果有该key值
      map .set(arr[i], true); 
    } else { 
      map .set(arr[i], false);   // 如果没有该key值
      array .push(arr[i]);
    }
  } 
  return array ;
}
 var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
    console.log(unique(arr))
//[1, "a", "true", true, 15, false, 1, {…}, null, NaN, NaN, "NaN", 0, "a", {…}, undefined]
```

创建一个空Map数据结构，遍历需要去重的数组，把数组的每一个元素作为key存到Map中。由于Map中不会出现相同的key值，所以最终得到的就是去重后的结果。

### 11. 利用reduce+includes

```coffeescript
function unique(arr){
    return arr.reduce((prev,cur) => prev.includes(cur) ? prev : [...prev,cur],[]);
}
var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
console.log(unique(arr));
// [1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", {…}, {…}]
```

### 12. [...new Set(arr)]

```js
[...new Set(arr)] 
//代码就是这么少----（其实，严格来说并不算是一种，相对于第一种方法来说只是简化了代码）
```







## 10. 如何对比两个数组是否相等？

```js
const a = [1, 2, 3]
const b = [1, 2, 3]
a === b // false
```

直接对比是不行的，因为在JavaScript中，数组和对象是按引用而不是按值进行比较的。



**JSON.stringify 转为字符串后在进行对比**

```js
const equals = (a,b) => JSON.stringify(a) === JSON.stringify(b)

const a = [1,2,3]
const b = [1,2,3]

equals(a, b) // true
```

但是某种情况下会有问题

```js
// 接上个代码段
const str = 'a'
const strObj = new String('a')

str === strObj // false
equals([str], [strObj]) // true,

null === undefined // false
equals([null] , [undefined]) // true 


// 扩展
    console.log(
        null == undefined,              //true
        null === undefined,             //false

        JSON.stringify([null]),         //[null]
        JSON.stringify([undefined]),    //[null]
        JSON.stringify([null]) === JSON.stringify([undefined]), // true

    )
```



**更好的方式 用Array.prototype.every()**

```js
const equals = (a, b) =>  a.length === b.length &&  a.every((v,i) => v === b[i])
 
 
const a = [1,2,3]
const b = [1,2,3]
const str = 'a'
const strObj = new String('a')

equals(a,b) // true
equals([str], [strObj]) // false
equals([null], [undefined]) // false
```



**如何数组是乱序如何处理 用Array.prototype.filter()**

```js
 const equalsIgnoreOrder = (a, b) => {
        if (a.length !== b.length) return false
        const uniqueValues = new Set([...a, ...b])
        for (const v of uniqueValues) {
            const aCount = a.filter(e => e === v).length
            const bCount = b.filter(e  => e === v).length
            if (aCount != bCount) return false
        }
        return true
    }

```

```js
   // 这种方式局限于 有顺序的数组 不能有NaN  可以有数组
    Array.prototype.equals = function (array) {
        if (!array) return false;
        if (this.length != array.length) return false;

        for (var i = 0, l = this.length; i < l; i++) {
            if (this[i] instanceof Array && array[i] instanceof Array) {
                if (!this[i].equals(array[i]))
                    return false;
            }
            else if (this[i] != array[i]) {
                return false;
            }
        }
        return true;
    }
```



## 11. 判断两个对象是否相同

**ES6中有⼀个⽅法判断两个对象是否相等，这个⽅法判断是两个对象引⽤地址是否⼀致**

```js
let obj1 = {
        a: 1
    }
let obj2 = {
    a: 1
}
let obj3 = obj1
    
    console.log(Object.is(obj1, obj2)) // false
    console.log(Object.is(obj2, obj3)) // false
    console.log(Object.is(obj1, obj3)) // true
```

当需求是⽐较两个对象内容是否⼀致时就没⽤了。
**想要⽐较两个对象内容是否⼀致，思路是要遍历对象的所有键名和键值是否都⼀致：**
1、判断两个对象是否指向同⼀内存
2、使⽤Object.getOwnPropertyNames获取对象所有键名数组
3、判断两个对象的键名数组是否相等
4、遍历键名，判断键值是否都相等

```js
 let obj1 = {
        a: 1,
        b: {
            c: 2
        }
    }
    let obj2 = {
        b: {
            c: 3
        },
        a: 1
    }
    
   
     let obj3 = {
        a: 1,
        b: {
            c: [1,2]
        }
    }
    let obj4 = {
        b: {
            c: [2,1]
        },
        a: 1
    }
    
    function isObjectValueEqual(a, b) {
        // 判断两个对象是否指向同⼀内存，指向同⼀内存返回true
        if (a === b) return true
        // 获取两个对象键值数组
        let aProps = Object.getOwnPropertyNames(a)
        let bProps = Object.getOwnPropertyNames(b)
        // 判断两个对象键值数组长度是否⼀致，不⼀致返回 false
        if (aProps.length !== bProps.length) return false
        // 遍历对象的键值
        for (let prop in a) {
            // 判断a的键值，在b中是否存在，不存在，返回false
            if (b.hasOwnProperty(prop)) {
                // 判断a的键值是否为对象，是则递归，不是对象直接判断键值是否相等，不相等返回false
                if (typeof a[prop] === 'object') {
                    if (!isObjectValueEqual(a[prop], b[prop])) return false
                } else if(a[prop] !== b[prop]) {
                    return false
                }
            } else {
                return false
            }
        }
        return true
    }

    console.log(isObjectValueEqual(obj1, obj2))  // true
	console.log(isObjectValueEqual(obj3, obj4))  // false
```



## 12. 深拷贝

```js
 function deepClone(obj) {
        let objClone = Array.isArray(obj) ? [] : {};
        if (obj && typeof obj === "object") {
            for (let key in obj) {
                if (obj.hasOwnProperty(key)) {
                    //判断obj⼦元素是否为对象，如果是，递归复制
                    if (obj[key] && typeof obj[key] === "object") {
                        objClone[key] = deepClone(obj[key]);
                    } else {
                        //如果不是，简单复制
                        objClone[key] = obj[key];
                    }
                }
            }
        }
        return objClone;
    }

    let a = [1, 2, 3, 4, [1, 2]], b = deepClone(a);
    let e = { a: 123, b: { c: 123 } }, f = deepClone(e);

    // a[0] = 2;
    // console.log(a, b)

    e.b.a = 456;
    console.log(e, f)
```

## 13. flex

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        * {
            padding: 0px;
            margin: 0px;
        }

        .father {
            height: 760px;
            border: 20px solid pink;
            display: flex;
            justify-content:center;
            align-items: center;
            /* flex-wrap: wrap-reverse; */

            /* justify-content: flex-start; */
            /* justify-content: flex-end; */
            /* 平分布局  */
            /* justify-content: space-around;   */
            /* 左右两端紧贴边框 中间平分 */
            /* justify-content: space-between;   */
            /* 每个元素所有都是平分布局 */
            /* justify-content: space-evenly;   */
            /* justify-content: center; */

            /* flex-direction:row-reverse; */
            /* flex-direction:column; */
            /* flex-direction:column-reverse; */

            /* 用于父元素的属性 */
            /* display:flex;
            flex-direction:xx ;
            flex-wrap:xx ;
            justify-content: xx;
            align-items: xx; */


            /* 用于子元素上的属性 */
            /* flex-grow: 1;  百分比
            flex-shrink: 0; 不允许被挤压 1 挤压为原来的一半
            flex-basis: xx;
            flex: xx;  组合属性 前三个
            align-self: xx; 覆盖父属性的值
            order: xx; 默认为0 值越小越靠前


            */ 
        }

        .box {
            height: 200px;
        }

        .box1 {
            background-color: red;
            width: 200px;
            align-self: flex-start;
            flex: 1;
            order: 3;
          
           
        }

        .box2 {
            background-color: green;
            width: 200px;
            flex: 1;
            order: 2;
            
        }

        .box3 {
           
            background-color: blue;
            width: 200px;
            align-self: flex-end;
            flex: 2;
            order: 1;

        }
    </style>
</head>

<body>
    <div class="father">
        <div class="box box1">1</div>
        <div class="box box2">2</div>
        <div class="box box3">3</div>
    </div>
</body>

</html>
```

## 14. react跨域问题

> 跨域问题可以说是前后端分离项目中经常面对的问题，事实上解决跨域问题的方法也有很多种，本篇文章将针对React项目在开发以及部署到`Nginx`服务器后如何解决跨域问题进行讲解，希望对大家有所帮助。

#### 一、开发模式——配置代理

我们在开发前端项目的时候，涉及到网络请求的部分难免会遇到跨域问题，由于是在本地开发，此时我们可以使用代理的方式来快速解决这个问题。

##### 方法一：配置package.json

在package.json中追加如下配置，对应后端的ip和端口即可。



```json
"proxy":"http://localhost:5000"
```

###### 说明：

1. 优点：配置简单，前端请求资源时可以不加任何前缀。
2. 缺点：不能配置多个代理！！！如果说前端需要请求多个不同端口/域名的服务器的话，那么就不能通过这种方式解决。
3. 工作方式：上述方式配置代理，当请求了3000不存在的资源时，那么该请求会转发给5000 （优先匹配前端资源）

##### 方法二

1. 第一步：创建代理配置文件

   ```undefined
   在src下创建配置文件：src/setupProxy.js
   ```

2. 编写setupProxy.js配置具体代理规则：

   ```js
   const proxy = require('http-proxy-middleware')
   
   module.exports = function(app) {
     app.use(
       proxy('/api1', {  //api1是需要转发的请求(所有带有/api1前缀的请求都会转发给5000)
         target: 'http://localhost:5000', //配置转发目标地址(能返回数据的服务器地址)
         changeOrigin: true, //控制服务器接收到的请求头中host字段的值
         /*
            changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000
            changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:3000
            changeOrigin默认值为false，但我们一般将changeOrigin值设为true
         */
         pathRewrite: {'^/api1': ''} //去除请求前缀，保证交给后台服务器的是正常请求地址(必须配置)
       }),
       proxy('/api2', { 
         target: 'http://localhost:5001',
         changeOrigin: true,
         pathRewrite: {'^/api2': ''}
       })
     )
   }
   ```

##### 说明：

1. 优点：**可以配置多个代理**，可以灵活的控制请求是否走代理。
2. 缺点：配置繁琐，前端请求资源时必须加前缀。

需要注意的是，在创建React脚手架的时候就已经默认有`http-proxy-middleware`模块了，如果没有的话，则手动执行：`yarn add http-proxy-middleware`来下载。需要注意的是，`http-proxy-middleware`模块的引入可能会因为版本问题而报错。如果上面的引入方式报错的话，那么就需要改为下面这种方式（对应使用到`proxy`的地方也要换成`createProxyMiddleware`）,因为这个中间件最新的1.0.0版本已经对模块的引用作了明确的要求：



```jsx
const { createProxyMiddleware } = require('http-proxy-middleware');
```

#### 二、生产模式or正式部署到Nginx服务器上

我们知道，我们执行`npm start`能够把前端项目跑起来实际上是因为我们把项目放在了node帮我们启动的服务器上面，但是遗憾的是，我们原先配置的代理，在我们把打包后的文件部署到Nginx后，是不起作用的。
这个时候，我们就不得不重新面对跨域这个问题了，其实解决的问题也有很多

##### （1）如果是后台是Java项目的话，可以在后端配置同源Cors。

##### （2）如果后台不解决，那么我们可以通过Nginx的反向代理来解决这个问题

比如说，我们有个前端的请求是：`ip:port/s1/custom/add`，现在我们想要把`/s1`开头的请求转发到其他服务器来处理，我们可以这么配置：



```kotlin
 server {
        listen       3000;
        server_name  localhost;
      ...
        location /s1 {
           proxy_pass https://xxxx.xxxx.com/;
           rewrite "^/s1/(.*)$" /$1 break;
        }
}
```

当nginx匹配到`/s1`开头的请求时，就会重写请求路径，根据上面的正则配置，会取出`/s1`部分后面的内容作为新的请求路径，最终代理服务器拼接后的结果是：`ip:port/custom/add`。通过这种方式，我们就可以解决前端项目跨域请求的问题啦。



## 15. 相对定位绝对定位

**一：绝对定位**

position: absolute;绝对定位：绝对定位是相对于元素**最近的已定位的祖先元素（**即是设置了绝对定位或者相对定位的祖先元素）。如果元素没有已定位的祖先元素，那么它的位置则是相对于**最初的包含块（body）**。

绝对定位与文档流无关，所以它们可以覆盖页面上其他的元素，可以通过z-index属性来控制这些层的对方顺序。

\#box_relative {
 position: absolute;
 left: 30px;
 top: 20px;
}

 

![css绝对定位和相对定位的区别 - Amy - Amy——做一根有思想的芦苇](http://www.w3school.com.cn/i/ct_css_positioning_absolute_example.gif)

 

**二：相对定位**

position: relative;相对定位：相对定位是相对于元素在文档中的**初始位置**；

注意，在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。


\#box_relative {
 position: relative;
 left: 30px;
 top: 20px;
}

![css绝对定位和相对定位的区别 - Amy - Amy——做一根有思想的芦苇](http://www.w3school.com.cn/i/ct_css_positioning_relative_example.gif)

注意：position:absolute，float会隐式地改变display的类型（display：none除外）。即是当元素设置position:absolute、float:left、float:right中任意一个时，都会让元素以display:inline-block的方式显示（特点是：可以设置长宽，默认宽度不占满父元素）。这时，即使故意设置display:inline; display:block都是无效的。

但是float在IE6下的双边距bug就是用display:inline; 来解决的。
position:relative不会隐式改变display的类型。

## 16. promise generator async/await

>  async / await 是Generator函数的语法糖，原理是通过Generator函数 + 自动执行器 实现的，这使得async / await 跟普通函数一样，不用一直 next( ) 执行了。

```js
 // 打印省市区
 // promise模式
    new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve("省")
        }, 1000);
    }).then(a => {
        console.log(a);
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                resolve("市")
            }, 1000)
        })
    }).then(a => {
        console.log(a)
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                resolve("区")
            }, 1000)
        })
    }).then(a => {
        console.log(a)
    })

//使用generator
    function* gen() {
        yield Promise.resolve("省")
        yield Promise.resolve("市")
        yield Promise.resolve("区")

    }

    let g = gen();
    g.next().value.then(res => { console.log(res) })
    g.next().value.then(res => { console.log(res) })
    g.next().value.then(res => { console.log(res) })

// 使用async/await
    async function asy() {
        let p1 = await new Promise(resolve=>{
            setTimeout(() => {
                resolve("省")
            }, 1000);
        })
        console.log(p1)
        let p2 = await new Promise(resolve=>{
            setTimeout(() => {
                resolve("市")
            }, 1000);
        })
        console.log(p2)
        let p3 = await new Promise(resolve=>{
            setTimeout(() => {
                resolve("区")
            }, 1000);
        })

        console.log( p3)
    }
    asy()
```

## 17. async/await执行顺序

2021-05-08 09:59:43

```js
 	async function func1() {
        return 1
    }

    func1().then(res=>console.log(res))
    console.log("123")

	// 1 2 3 1
```



### 1、什么是async、await？

>  async / await 是Generator函数的语法糖，原理是通过Generator函数 + 自动执行器 实现的，这使得async / await 跟普通函数一样，不用一直 next( ) 执行了。

例子1

```javascript
   function f(){
      return new Promise((resolve,reject)=>{
        resolve('f 函数执行成功的结果');
      });
    }
    async function doo(){
      let x = await f();  
      console.log(x);
    }
    async function foo(){
      let y = await 6;
      console.log(y);
    }
    doo();
    foo();
    console.log('start:');


	------打印结果：----------------------
	
	start:
	f 函数执行成功的结果
	6
```

- 首先，看了上面例子，书本上 介绍的 async 特点，被证实的有：
  1. 函数前面 async 修饰，标明它是一个异步函数；
  2. await 运算符，它会阻塞后面的代码 ；
  3. await 表达式返回的值：如果是promise对象，则得到起resolve的值（你也可接受reject的返回值，那么 let x = await f(); 处需有catch处理）
- 疑惑：await 后面接一个函数或 实际值，跟接Promise对象，执行顺序是怎样的？

### 2、Generator 函数介绍

>  Generator函数是一个状态机，封装了多个内部状态。（也就是《JavaScript高级程序设计》里介绍的生成器）。
>  它有几个特点：
>   1. 返回值：返回一个**遍历器对象**
>   2. 只有调用 **next** 方法才会遍历下一个内部状态
>   3. 函数内 **yield** 表示暂停状态

**Generator函数暂停 / 执行的原理**

> 先了解下协程的概念：
>  一个**线程 A** 执行到一半的时候，可以暂停执行，将执行权交给**B线程**，等稍后收回执行权的时候，**A再恢复**执行。这种可以并行执行、交换执行权的线程（A）叫做**协程**。

- 自动执行器

### 3. async / await 执行顺序

通过例子阐述：

- await 后面是Promise对象时：

```javascript
   console.log('1')
    async function async1() {
      await async2();
      console.log('2')
    }
    function async2() {
      console.log('3');
      return new Promise((resolve,reject)=>{
        console.log("4");
        resolve(33);
      })
    }
    async1();
    new Promise(resolve => {
        console.log('5')
        resolve()
      })
      .then(function () {
        console.log('6')
      })
      .then(function () {
        console.log('7')
      })
    console.log('8')
    ------------------打印结果-----------
   // 1 3 4 5 8 2 6 7
```

- await 后面是 **非Promise对象** 时：

```javascript
   console.log(1)

    async function async1() {
        await async2();
        console.log(2)
    }
    //区别在这 aysnc2 函数的返回值
    function async2() {
        console.log(3);
    }
    async1();
    new Promise(resolve => {
        console.log(4)
        resolve()
    })
        .then(function () {
            console.log(5)
        })
        .then(function () {
            console.log(6)
        })
    console.log(7)


    // 1 3 4 7 2 5 6
```

- 当await 接收的值非Promise 对象时，它会将返回值包装成Promise.then(返回值)将值和恢复执行的消息一起添加到消息队列中；
- 如果是Promise对象，**先添加到消息队列，等待可用值**；等有可用值后**再把恢复执行的消息添加到消息队列**；有两个添加到消息队列的操作。



## 18. 字符串更改queryString

**有这样一个字符串"http://www.baidu.com?a=1&b=2&c=&a=5&d=xxx",要求转化成 {"a":[1,5],"b":2,"c":,"d":xxx}**

```js
 function fn2(str) {
​    let index = str.indexOf("?");			
​    let newStr = str.slice(index + 1);
​    let arr2 = newStr.split("&").map(v => v.split("="));
​    let obj = {}

​    arr2.forEach(v => {
​      if (!obj[v[0]]) {      //判断这个键有没有在obj中  没有那么就添加
​        obj[v[0]] = v[1]
​      } else {
​        obj[v[0]] = [...obj[v[0]], v[1]];  // 如果有那么就合并为数组 
​      }
​    })

​    return obj;
  }

  let str = "http://www.baidu.com?a=1&b=2&c=&a=5&d=xxx&b=456&b=789";
  console.log( fn2(str))
```



## 19.冒泡、捕获、阻止、委托

![image-20220407124751118](C:/Users/刘先生/Desktop/js-Md/typora-user-images/image-20220407124751118.png)

```js
const div1 = document.querySelector('[class=div1]');
const div2 = document.querySelector('[class=div2]');
const div3 = document.querySelector('[class=div3]');
const div4 = document.querySelector('[class=div4]');

// 1. 全部是冒泡
div1.addEventListener('click',function(){ console.log('冒泡div1');})
div2.addEventListener('click',function(){ console.log('冒泡div2');})
div3.addEventListener('click',function(){ console.log('冒泡div3');})
div4.addEventListener('click',function(){ console.log('冒泡div4');})

// 点击div4 冒泡4 > 冒泡3 > 冒泡2 > 冒泡1


// 2. 全部是捕获
div1.addEventListener('click',function(){ console.log('捕获div1');},true)
div2.addEventListener('click',function(){ console.log('捕获div2');},true)
div3.addEventListener('click',function(){ console.log('捕获div3');},true)
div4.addEventListener('click',function(){ console.log('捕获div4');},true)

// 点击div4 捕获1 > 捕获2 > 捕获3 > 捕获4



// 3. 既有冒泡 又有捕获 又有目标元素冒泡与捕获
div1.addEventListener('click', function () { console.log('捕获div1'); }, true)
div2.addEventListener('click', function (e) {console.log('冒泡div2'); })
div3.addEventListener('click', function () { console.log('捕获div3'); }, true)
div4.addEventListener('click', function () { console.log('冒泡div4'); })
div4.addEventListener('click', function () { console.log('捕获div4'); }, true)

// 点击div4 捕获div1 > 捕获div3 > 捕获div4 > 冒泡div4 > 冒泡div2



// 4. stopPropagation
div1.addEventListener('click', function () { console.log("捕获div1"); }, true)
div2.addEventListener('click', function () { console.log("冒泡div2"); })
div3.addEventListener('click', function () { console.log('捕获div3'); }, true)
div4.addEventListener('click', function (e) { console.log('冒泡div4'); e.stopPropagation(); })
div4.addEventListener('click', function () { console.log('捕获div4'); }, true)

// 点击div4  捕获div1 > 捕获div3 > 捕获div4 > 冒泡div4


// 5.  stopPropagation 2
div1.addEventListener('click', function () { console.log("捕获div1");}, true)
div2.addEventListener('click', function (e) { console.log("冒泡div2"); event.stopPropagation();})
div3.addEventListener('click', function () { console.log('捕获div3');}, true)
div4.addEventListener('click', function () { console.log('冒泡div4');})
div4.addEventListener('click', function () { console.log('捕获div4');}, true)

// 点击 div4 捕获div1 > 捕获div3 > 捕获div4 > 冒泡div4 > 冒泡div2


// 总结 阻止冒泡还是捕获 都是要走一遍 遇到event.stopPropagation()  整个事件流就停止了 
// retrun false 听说也是 阻止 事件冒泡捕获  但是自己没有成功 （在dom2级别事件中）




// 6. 事件委托
document.querySelector("ul").addEventListener('click', function (e) {
var event = e || window.event;
var target = event.target || event.srcElement;
if (target.nodeName.toLocaleLowerCase() === 'li') {
	console.log('the content is: ', target.innerHTML);
}
});

// 在上述代码中， target 元素则是在 #list 元素之下具体被点击的元素，
// 然后通过判断 target 的一些属性（比如：nodeName，id 等等）可以更
// 精确地匹配到某一类 #list li 元素之上；
```



## 20. axios 请求拦截器&响应拦截器

![img](https://csdnimg.cn/release/blogv2/dist/pc/img/reprint.png)

[初学者0721](https://blog.csdn.net/weixin_44428734)![img](https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png)于 2021-09-03 11:12:43 发布![img](https://csdnimg.cn/release/blogv2/dist/pc/img/articleReadEyes2.png)1079![img](https://csdnimg.cn/release/blogv2/dist/pc/img/tobarCollect2.png) 收藏 13

分类专栏： [vue](https://blog.csdn.net/weixin_44428734/category_11304562.html) 文章标签： [vue.js](https://so.csdn.net/so/search/s.do?q=vue.js&t=blog&o=vip&s=&l=&f=&viparticle=) [java](https://so.csdn.net/so/search/s.do?q=java&t=blog&o=vip&s=&l=&f=&viparticle=)

版权

[![img](https://img-blog.csdnimg.cn/20201014180756927.png?x-oss-process=image/resize,m_fixed,h_64,w_64)vue专栏收录该内容](https://blog.csdn.net/weixin_44428734/category_11304562.html)

10 篇文章0 订阅

订阅专栏

### 一、 [拦截器](https://so.csdn.net/so/search?q=拦截器&spm=1001.2101.3001.7020)介绍

一般在使用[axios](https://so.csdn.net/so/search?q=axios&spm=1001.2101.3001.7020)时，会用到拦截器的功能，一般分为两种：请求拦截器、响应拦截器。

1. 请求拦截器
   在请求发送前进行必要操作处理，例如添加统一cookie、请求体加验证、设置请求头等，相当于是对每个接口里相同操作的一个封装；
2. 响应拦截器
   同理，响应拦截器也是如此功能，只是在请求得到响应之后，对响应体的一些处理，通常是数据统一处理等，也常来判断登录失效等。

### 二、 Axios实例

1. 创建axios实例

   ```javascript
   // 引入axios
   
   
   
   import axios from 'axios'
   
   
   
    
   
   
   
   // 创建实例
   
   
   
   let instance = axios.create({
   
   
   
       baseURL: 'xxxxxxxxxx',
   
   
   
       timeout: 15000  // 毫秒
   
   
   
   })
   ```

   

2. baseURL设置：

   ```javascript
   let baseURL;
   
   
   
   if(process.env.NODE_ENV === 'development') {
   
   
   
       baseURL = 'xxx本地环境xxx';
   
   
   
   } else if(process.env.NODE_ENV === 'production') {
   
   
   
       baseURL = 'xxx生产环境xxx';
   
   
   
   }
   
   
   
    
   
   
   
   // 实例
   
   
   
   let instance = axios.create({
   
   
   
       baseURL: baseURL,
   
   
   
       ...
   
   
   
   })
   ```

3. 修改实例配置的三种方式

   ```javascript
   // 第一种：局限性比较大
   
   
   
   axios.defaults.timeout = 1000;
   
   
   
   axios.defaults.baseURL = 'xxxxx';
   
   
   
    
   
   
   
   // 第二种：实例配置
   
   
   
   let instance = axios.create({
   
   
   
       baseURL: 'xxxxx',
   
   
   
       timeout: 1000,  // 超时，401
   
   
   
   })
   
   
   
   // 创建完后修改
   
   
   
   instance.defaults.timeout = 3000
   
   
   
    
   
   
   
   // 第三种：发起请求时修改配置、
   
   
   
   instance.get('/xxx',{
   
   
   
       timeout: 5000
   
   
   
   })
   ```

   这三种修改配置方法的优先级如下：请求配置 > 实例配置 > 全局配置

### **三、 配置拦截器**

```javascript
// 请求拦截器



instance.interceptors.request.use(req=>{}, err=>{});



// 响应拦截器



instance.interceptors.reponse.use(req=>{}, err=>{});
```

从上可以看出，instance依然是第二步中创建的实例，然后对其进行拦截，请求用request，响应用reponse，二者都有两个配置项，一个是成功配置，一个是error配置。

1. 请求拦截器

   ```javascript
   // use(两个参数)
   
   
   
   axios.interceptors.request.use(req => {
   
   
   
       // 在发送请求前要做的事儿
   
   
   
       ...
   
   
   
       return req
   
   
   
   }, err => {
   
   
   
       // 在请求错误时要做的事儿
   
   
   
       ...
   
   
   
       // 该返回的数据则是axios.catch(err)中接收的数据
   
   
   
       return Promise.reject(err)
   
   
   
   })
   ```

   

2. 响应拦截器

   ```javascript
   // use(两个参数)
   
   
   
   axios.interceptors.reponse.use(res => {
   
   
   
       // 请求成功对响应数据做处理
   
   
   
       ...
   
   
   
       // 该返回的数据则是axios.then(res)中接收的数据
   
   
   
       return res
   
   
   
   }, err => {
   
   
   
       // 在请求错误时要做的事儿
   
   
   
       ...
   
   
   
       // 该返回的数据则是axios.catch(err)中接收的数据
   
   
   
       return Promise.reject(err)
   
   
   
   })
   ```

   

3. 常见错误码处理(error)

   axios请求错误时，可在catch里进行错误处理。

   ```javascript
   axios.get().then().catch(err => {
   
   
   
       // 错误处理
   
   
   
   })
   ```

   但实际开发过程中，一般在请求/响应拦截器中统一做错误处理，有特殊接口的话做单独的catch错误处理

### 四、 axios请求拦截器的案例 

axios请求发送之前，拦截请求，在请求中加入从cookie中获取到的csrftoken值。以解决后端接口[csrf](https://so.csdn.net/so/search?q=csrf&spm=1001.2101.3001.7020)验证问题。

如下，可以在vue项目的src目录下新建一个axios_instance.js文件，用于创建一个axios实例和进行相关配置。

```javascript
import axios from 'axios'

// 创建一个axios实例

const axios_instance = axios.create()


// 设置axios拦截器：请求拦截器

axios_instance.interceptors.request.use(config => {

  //请求拦截一般会有哪些操作



  // 1.比如config中的一些信息不符合服务器的要求,这里可以做一些修改



  // 2.比如每次发送网络请求时,都希望在界面中显示一个请求的图标(然后再响应拦截中取消显示)



  // 3.某些网络请求必须携带一些特殊的信息(如登录token),如果没有携带就可以拦截并作响应提示



  // 给请求头添加token

  /*


  * 其中   /.*csrftoken=([^;.]*).*$/    是一个正则表达式，用于从cookie中获取csrftoken的值 ，

  * ([^;.]*) 是命名捕获，表示从匹配到的内容中 只获得 ()内的值。

  * string.match(regex) 得到的是一个数组， 第0项是匹配到的全部内容，第1项是通过命名捕获得到的内容，在这里就是csrftoken的值。

  * 这样就完成了使用axios发送请求的正确配置了，同时保证了网站免受csrf攻击的影响.

  */

  config.headers['X-Requested-With'] = 'XMLHttpRequest';

  let regex = /.*csrftoken=([^;.]*).*$/; // 用于从cookie中匹配 csrftoken值

  config.headers['X-CSRFToken'] = document.cookie.match(regex) === null ? null : document.cookie.match(regex)[1];



  return config



}, err => {

  // 请求未成功发出，如：没有网络...

  return Promise.reject(err)


})

// 设置axios拦截器: 响应拦截器



axios_instance.interceptors.response.use(res => {



  // 成功响应的拦截



  return Promise.resolve(res.data)



}, err =>{



  // 失败响应的拦截



  console.log(err)



  if(err.response){



    // 失败响应的status需要在response中获得



    console.log(err.response)



    switch(err.response.status){



      // 对得到的状态码的处理，具体的设置视自己的情况而定



      case 401:
          console.log('未登录')
          window.location.href='/'

          break

      case 404:

          window.location.href='/'

          break

      case 405:

          console.log('不支持的方法')

          break

      // case ...
      default:

          console.log('其他错误')
          break
    }

  }

  // 注意这里应该return promise.reject(),

  // 因为如果直接return err则在调用此实例时，响应失败了也会进入then(res=>{})而不是reject或catch方法

  return Promise.reject(err)

})

*/

export {

  axios_instance

}
 
```

**如此，
在需要拦截请求or响应的地方，就可以使用新建的axios实例来发起异步请求；
而不需要拦截请求/响应的地方，就可以直接使用axios来发起异步请求！！！**



# b. 第二阶段

## 1.react组件中箭头函数的使用

```js
const oDiv = document.querySelector('div');

// 普通函数
oDiv.addEventListener('click' , function() {})

// 箭头函数
oDiv.addEventListener('click' , () => {})
```

**0. this指向**

温故而知新：this 指针，是一个与执行上下文相关的特殊对象，也被称之为上下文对象。

在全局环境（全局执行上下文）中（在任何函数体外部的代码），this 始终- 指向全局对象(window，严格模式下是undefined)
在函数环境（函数执行上下文）中，this的值取决于函数的调用方式，如果被一个对象调用，那么this指向这个对象。否则this一般指向全局对象

**1. 普通function函数**

声明式 function fun() {} --- window
赋值式 const fun = function() {} --- window
forEach循环 — window
定时器,延时器 — window
对象中的函数 const obj = { fun: function(){} } — 对象本身(看具体调用方式，总之是fun的直接调用者)
事件绑定事件处理函数 oDiv.addEventListener('click' , function(){}) — 绑定事件的标签，如<div>...</div>

**2. 箭头函数**
因为没有prototype，箭头函数没有自己的this，它的函数体中使用的this，其实是继承自 定义它时所在的普通函数的this（如果定义在全局就指向全局对象window/undefined）。this是在上下文创建时确定的，因此箭头函数的父级（函数或全局对象）创建上下文时，箭头函数体内的this也可以说是“绑定”了。



```js
document.addEventListener('click', function() {
        console.log(this); // doucment
    })
document.addEventListener('click', ()=> {
    console.log(this); // window
})


    const oLis = document.querySelectorAll('li');
    oLis.forEach(function (item, key) {
        console.log(this);  // forEach函数的this指向，window 
        item.addEventListener('click', ()=> {
            // 箭头函数的this，跟随它的父级程序forEach函数，因此也是window
            console.log(key, this);                                    	 // window
        })
        
        // item.addEventListener('click',function() {
        //     // 箭头函数的this，跟随它的父级程序forEach函数，因此也是window      <li>...</li>
        //     console.log(key, this);
        // })
    })
```

**3. 番外——作用域链与原型链的区别：**

当访问一个变量时，解释器会先在当前作用域查找标识符，如果没有找到就去父作用域找，作用域链顶端是全局对象window，如果window都没有这个变量则报错。
当在对象上访问某属性时，首选会查找当前对象，如果没有就顺着原型链往上找，原型链顶端是null，如果全程都没找到则返一个undefined，而不是报错。

**4、箭头函数不能改变this指向**
箭头函数有个特性，就是它函数体内的this一旦绑定成功，就无法用显示绑定的方式去修改。

```js
function fn() {
    return () => {
        console.log(this.name);
    };
}
let obj1 = {
    name: '听风是风'
};
let obj2 = {
    name: '时间跳跃'
};
let bar = fn.call(obj1); // fn 的 this指向obj1，并返回了箭头函数赋给了bar
bar.call(obj2); // 听风是风
```


<span style="color:red">**bar就是箭头函数**</span>，可以看到当我们企图用call把它绑定给obj2并执行的时候，箭头函数内的this仍然指向obj1，显示绑定失败了。

这里指的是无法直接给箭头函数通过显示绑定修改this指向。修改外层函数this指向从而间接修改箭头函数this当然是可行的。

```js
function fn() {
    return () => {
        console.log(this.name);
    };
};
let obj1 = {
    name: '听风是风'
};
let obj2 = {
    name: '时间跳跃'
};
fn.call(obj1)(); //fn this指向obj1,箭头函数this也指向obj1
fn.call(obj2)(); //fn this 指向obj2,箭头函数this也指向obj2
```


**四、箭头函数的调用（这边以React组件举例）**
**1. 无参数**
可以直接使用函数名，因为整个函数赋值给了press，这样就不会出现初始化时自动调用。这种方式千万不要在后面加()

```react
press = () => {
  this.setState({
    data: 1
  })
};
<Text onPress={this.press}>{this.state.data}</Text>
```


**2. 有参数**
必须使用箭头函数的形式调用，因为加括号会直接调用函数

```react
press = (num) => {
  this.setState({
    data: num
  })
};
<Text onPress={() => this.press(2)}>{this.state.data}</Text>
```

**3. 而在组件中定义的普通函数，就只能用箭头函数或者绑定this的方式来调用了，因为否则它的this会指向window/undefined**

```react
press(num) {
  this.setState({
    data: 1,
    count: num
  })
};
// 无参数
<Text onPress={() => this.press()}>{this.state.data}</Text>
// 或者
<Text onPress={this.press.bind(this)}>{this.state.data}</Text>
// 有参数
<Text onPress={() => this.press(2)}>{this.state.data}</Text>
<Text onPress={this.press.bind(this,2)}>{this.state.data}</Text>
```


**4 传递React 的事件对象 e**

```react
<button onClick={(e) => this.deleteRow(id, e)}>Delete Row</button>
<button onClick={this.deleteRow.bind(this, id)}>Delete Row</button>
```


在这两种情况下，React 的事件对象 e 会被作为第二个参数传递。如果通过箭头函数的方式，事件对象必须显式的进行传递，而通过 bind 的方式，事件对象以及更多的参数将会被隐式的进行传递。

**5 补充一下在React组件（ES6 Class类）中的定义方法时，使用普通函数和箭头函数的区别**

```react
class App extends Component {
  fun1() {}

  fun2 = () => {}
}


```

fun1是App类原型方法的定义，宽松模式下对应 ES5 构造函数的写法就是App.prototype.fun1 = function() {}
fun2则是 Stage 2 Public Class Fields 里面的写法，也就是实例方法，babel 下需要用 Class properties transform Plugin 进行转义。相当于：

```js
class App extends Component {
  constructor (...args) {
    super(...args)
    this.fun2 = () => {
    }
  }
}


我们先看一个ES5构造函数的例子，来回顾下类中方法定义的区别。

function Cat(name) {
  this.name = name || '咪咪'
  this.meow = function() {
    console.log('实例方法',this)
  }
  console.log(this) // Cat {name: "花花", meow: ƒ} // 构造函数的this指向实例
}
Cat.eat = function() {
  console.log('静态方法',this) 
}
Cat.prototype.sleep = function() {
 console.log('原型方法',this) // 还是看直接调用者，实例调用就指向实例，prototype调用就指向原型
}
let littleCat = new Cat('花花')
// Cat.meow() // 报错，Cat.meow is not a function
littleCat.meow() //  实例方法

Cat.eat()  // 静态方法, this 指向构造函数本身
// littleCat.eat() // 报错，littleCat.eat is not a function，实例不能访问静态方法

// Cat.sleep() // Cat.sleep is not a function
Cat.prototype.sleep() // 构造函数原型方法必须用  类名.prototype.方法名 调用 ，否则如上会报错
littleCat.sleep() // 原型方法


```

由此可见，原型方法的this是不固定的，依赖它的直接调用者。而实例方法只有实例可以调用，且永远指向实例本身
再加个题外话，用面向对象的思维，class声明的类也是一个对象，就像如下的obj。在ES6类中以fun() {}这种形式定义方法，就是给对象的fun属性赋值一个匿名函数的简洁语法。当然普通的对象（非函数）没有prototype，当然也没有原型方法。这边只是类比。而且用class构造类时不能用第二种方式定义方法。这里提一嘴就是强调千万不要把fun() {}和声明式的具名函数弄混淆了，它仍然只是把匿名函数的地址赋值给一个变量而已。

```jsx
let obj = {
  fun() { console.log(this) }
}
// 等同于
let obj = {
  fun: function() {
    console.log(this)
  }
}
```


在React组件中使用原型方法，比如传入子组件或作为事件回调时，需要手动绑定this，不然会找不到正确的this。
像这样

<button onClick={this.handleClick.bind(this)}></button>

再看ES6的写法如何确定原型方法的this。如下只有第一种方式(直接使用this.jump)不能指向Dog的实例。

由此我们可以看出，this需要明确指向组件实例的时候，以箭头函数的形式定义实例方法，可以省去很多麻烦。

```react
class Dog extends React.Component { 
  constructor(props){
    super(props)
    this.name = '旺财'
    this.eat = this.eat.bind(this) // 如果定义为原型方法，React的推荐写法
    console.warn(this.name) // 旺财
  }
  jump() {
    console.warn('原型方法调用时候绑定组件实例this', this.name)
  }
  eat() {
    console.warn('原型方法在constructor绑定组件实例this', this.name)
    // // 现在this也指向Dog的实例了
  }
  drink() {
    console.warn('原型方法调用时用箭头函数绑定this', this.name)
  }
  run = (arg) => { // 也是React官方推荐的写法
    console.warn('实例方法', this.name, arg)  // this永远指向Dog的实例
  }
  render() {
    return (
      <View
        style={{
          flex: 1,
          justifyContent: "center",
          alignItems: "center"
        }}>
        <Text onPress={this.jump}>原型方法直接使用时</Text>
        <Text>-------------------------------------------------------------</Text>
        <Text onPress={this.jump.bind(this)}>原型方法调用时绑定组件实例this</Text>
        <Text>-------------------------------------------------------------</Text>
        <Text onPress={this.eat}>原型方法在构造函数中绑定组件实例this</Text>
        <Text>-------------------------------------------------------------</Text>
        <Text onPress={() => this.drink()}>原型方法调用时用箭头函数绑定this</Text>
        <Text>-------------------------------------------------------------</Text>
        <Text onPress={this.run}>实例方法无参情况直接使用</Text>
        <Text>-------------------------------------------------------------</Text>
        <Text onPress={(e) => this.run('汪汪汪',e)}>实例方法有参情况使用</Text>
      </View>
    )
  }
}

第一个会报错，this找不到
第二个
第三个

第四种

第五种

第六种
```

上面除了第一种<Text onPress={this.jump}>原型方法直接使用时</Text>虽然都能实现需求，但第四种<Text onPress={() => this.drink()}>原型方法调用时用箭头函数绑定this</Text>，问题在于每次渲染 Dog 时都会创建不同的回调函数。在大多数情况下都没什么问题，但如果该回调函数作为 prop 传入子组件时，这些组件可能会进行额外的重新渲染。因此通常还是建议run = () => {}箭头函数的写法（class fields语法）和在构造器种绑定this的方式。
————————————————
版权声明：本文为CSDN博主「雨浅听风吟」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_39289876/article/details/122534211

## 2. Hash模式跟history模式的区别

**1. hash模式**

1. hash值得变化不会向后端发送请求，后端检测不到前端路由得变化
2. 而且 hash 改变会触发 hashchange 事件，浏览器的进后退也能对其进行控制

3. hash 本来是拿来做页面定位的，如果拿来做路由的话，原来的锚点功能就不能用了
4. hash 的传参是基于 url 的，如果要传递复杂的数据，会有体积的限制
5. 不美观得问题

​	------------------------------------------------------------------------------------------------------------------------------------

  **2. history模式**

1. history 模式不仅可以在url里放参数，还可以将数据存放在一个特定的对象中

2. 但是它也有个问题：不怕前进，不怕后退，就怕刷新，（如果后端没有准备的话），因为刷新是实实在在地去请求服务器的。



  **3. 主要得区别**

​	在hash模式下，前端路由修改的是#中的信息，而浏览器请求时不会将 # 后面的数据发送到后台，所以没有问题。

​	但是在history下，你修改path时，当刷新时，如果服务器中没有相应的响应或者资源，则会刷新出来404页面。


## 3. React跳转路由传参3种方法和区别

爱玩的小屁孩

于 2021-06-27 20:51:46 发布

186
 收藏 1
分类专栏： 小知识点 文章标签： react
版权

小知识点
专栏收录该内容
13 篇文章0 订阅
订阅专栏

**1. params传参**

**特点：路由表配置：参数地址栏显示**

```react
传入参数：
<Link to="/home/001/zhangsan/18" />

声明传参形式：
<Router path="/home/:id/:name/:age" component={Home} />"

接收参数：
在组件Home中接收使用this.props.match.params即可
```



**2. query传参**
**特点：query方法：参数地址栏不显示，刷新地址栏，参数丢失**

```react
传入参数：
<Link to="/home/?id=001&name=zhangsan&age=18" />

声明传参形式：无需声明
<Router path="/home" component={Home} />"

接收参数：
在组件Home中接收使用this.props.search.query即可
```


**3. state传参**
**特点：state方法：参数地址栏不显示，刷新地址栏，参数不丢失，不丢失的原因，this.history中存放了**

```react
传入参数：
<Link to="{pathname:'/home',state:{id:001,name:zhangsan,age:18}}" />

声明传参形式：无需声明
<Router path="/home" component={Home} />"

接收参数：
在组件Home中接收使用this.props.loaction.state即可
```

————————————————
版权声明：本文为CSDN博主「爱玩的小屁孩」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/yidianyuanzhidong/article/details/118279556



