<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generator</title>
</head>

<body>

</body>

</html>
<script>

    // 1 .生成器 简单的使用
    // function* generatorFn() {
    //     yield 'hello';
    //     yield 'world';
    //     return 'ending'
    // }
    // const gen = generatorFn();


    // 1-1 遍历方式1
    // for(let item of gen){
    //     console.log('item',item);
    // }
    // item hello
    // item world


    // 1-2 遍历方式2
    // console.log(
    //     gen.next(),
    //     gen.next(),
    //     gen.next(),
    //     gen.next(),
    //     gen.next()
    // );

    // gen.next()
    // // { value: 'hello', done: false }
    // gen.next()
    // // { value: 'world', done: false }
    // gen.next()
    // // { value: 'ending', done: true }
    // gen.next()
    // // { value: undefined, done: true }
    // gen.next()
    // // { value: undefined, done: true }




    // 2. for循环yeild
    // var arr = [1, [[2, 3], 4], [5, 6]];
    // var flat = function* (a) {
    //     var length = a.length;
    //     for (var i = 0; i < length; i++) {
    //         var item = a[i];
    //         if (typeof item !== 'number') {
    //             yield* flat(item);
    //         } else {
    //             yield item;
    //         }
    //     }
    // };

    // 2-1 遍历方式1
    // for (var f of flat(arr)) {
    //     console.log(f);      //1 2 3 4 5 6
    // }



    // 2-2 遍历方式2
    // const a = flat(arr)
    // console.log(a.next());      //{value: 1, done: false}
    // console.log(a.next());      //{value: 2, done: false}
    // console.log(a.next());      //{value: 3, done: false}
    // console.log(a.next());      //{value: 4, done: false}
    // console.log(a.next());      //{value: 5, done: false}
    // console.log(a.next());      //{value: 6, done: false}
    // console.log(a.next());      //{value: undefined, done: true}



    // 3.yield表达式如果用在另一个表达式之中，必须放在圆括号里面。
    // function* demo() {
    //     // console.log('Hello' + yield); // SyntaxError 
    //     // console.log('Hello' + yield 123); // SyntaxError
    //     console.log('Hello  ' + (yield)); // OK
    //     console.log('Hello  ' + (yield 123)); // OK
    // }

    // let d = demo();
    // d.next();  //Hello  undefined
    // d.next();  //Hello  undefined
    // d.next();



    // 4.yield表达式用作函数参数或放在赋值表达式的右边，可以不加括号。
    // function* demo() {
    //     foo(yield 'a', yield 'b'); // OK
    //     let input = yield; // OK
    // }



    // function* f() {
    //     for (var i = 0; true; i++) {
    //         var reset = yield i;
    //         console.log(reset);
    //         if (reset) { i = -1; }
    //     }
    // }
    // var g = f();
    // console.log(g.next());       // { value: 0, done: false }
    // console.log(g.next());       // { value: 1, done: false }          //undefined
    // console.log(g.next(true));   // { value: 0, done: false }          //true




    // 5. 由于next方法的参数表示上一个yield表达式的返回值，所以在第一次使用next方法时，传递参数是无效的
    // 从语义上讲，第一个next方法用来启动遍历器对象，所以不用带有参数。
    // function* foo(x) {
    //     var y = 2 * (yield (x + 1));
    //     var z = yield (y / 3);
    //     return (x + y + z);
    // }

    // var a = foo(5);
    // a.next() // Object{value:6, done:false}
    // a.next() // Object{value:NaN, done:false}
    // a.next() // Object{value:NaN, done:true}

    // var b = foo(5);
    // b.next() // { value:6, done:false }
    // b.next(12) // { value:8, done:false }
    // b.next(13) // { value:42, done:true }



    // 6. 斐波那契数 案列
    // function* fibonacci() {
    //     let [prev, curr] = [0, 1];
    //     for (; ;) {
    //         yield curr;
    //         [prev, curr] = [curr, prev + curr];
    //     }
    // }

    // for (let n of fibonacci()) {
    //     if (n > 20000) break;
    //     console.log(n);
    // }



    // let jane = { first: 'Jane', last: 'Doe' };
    // let arr = [123, 456, 789]

    // for (let i in arr) {
    //     console.log(i);

    // }

















</script>